#pragma kernel SubdivideSector

struct RodData
{
    int sector;
    float3 cornerVertex0; // 3 vertices of the rod
    float3 cornerVertex1;
    float3 cornerVertex2;
    float3 borderVertex0; // 3 vertices
    float3 borderVertex1;
    float3 borderVertex2;
    
    int triangulation0;
    int triangulation1;
    int triangulation2;
    int triangulation3;
    int triangulation4;
    int triangulation5;
    int triangulation6;
    int triangulation7;
    int triangulation8;
    int triangulation9;
    int triangulation10;
    int triangulation11;
    int triangulation12;
    int triangulation13;
    int triangulation14;
    int triangulation15;
    int triangulation16;
    int triangulation17;
    int triangulation18;
    int triangulation19;
    int triangulation20;
    
    float surfaceArea;
    float3 center;
};

struct SectorData
{
    int id;
    float3 cornerVertex0; // vertices of the larger triangle
    float3 cornerVertex1;
    float3 cornerVertex2;
};

int resolution; // Number of vertices along each edge (>=2)
int rodCountPerSector; // Expected to equal (resolution-1)^2
int rodCountTotal; // Total rods = rodCountPerSector * (number of sectors)
float displacementFactor;

RWStructuredBuffer<SectorData> sectors; // e.g., 20 sectors
RWStructuredBuffer<RodData> rods; // rodCountTotal entries

uint GetRowIndex(uint index)
{
    return floor(sqrt(index));
    //return (uint) floor((-1.0 + sqrt(1.0 + 8.0 * index)) / 2.0);
}

uint GetInRowIndex(uint index, uint row)
{
    return index - (row * row);
}

uint GetRowVertex(uint index)
{
    return (uint) floor((-1.0 + sqrt(1.0 + 8.0 * index)) / 2.0);
}

uint GetInRowVertex(uint index, uint row)
{
    return index - (row * (row + 1)) / 2;
}

float3 GridPoint(uint vertex, uint resolution, float3 A, float3 B, float3 C)
{
    uint row = GetRowVertex(vertex);
    uint col = GetInRowVertex(vertex, row);

    float s = float(row) / float(resolution - 1); // Normalize row index
    float3 vab = lerp(A, B, s);
    float3 vac = lerp(A, C, s);
    if (row == 0) // if row = 0, then it will just be at the A position, so prevent dividing by 0
    {
        return A;
    }
    float3 vpoint = lerp(vab, vac, float(col) / float(row)); // Correct col scaling
    return vpoint;
}

int GetVertex0(int triangleRow, int triangleInRow) //0, 0 returns 0
{
    return int((triangleRow * (triangleRow + 1.0f)) / 2.0f + (triangleInRow / 2.0f));
}

int GetVertex1(int triangleRow, int triangleInRow) //0, 0 returns 1
{
    int baseIndex = int(((triangleRow + 1.0f) * (triangleRow + 2.0f)) / 2.0f + (triangleInRow / 2.0f));
    return (triangleInRow % 2 == 0) ? baseIndex : baseIndex + 1;
}

int GetVertex2(int triangleRow, int triangleInRow) //0, 0 returns 2
{
    int baseIndex = int(((triangleRow + 1.0f) * (triangleRow + 2.0f)) / 2.0f + (triangleInRow / 2.0f));
    return (triangleInRow % 2 == 0) ? baseIndex + 1 : GetVertex0(triangleRow, triangleInRow) + 1;
}

void MapToTriangle(uint index, uint resolution, float3 A, float3 B, float3 C, out float3 v0, out float3 v1, out float3 v2)
{
    uint rowIndex = GetRowIndex(index);
    uint inRowIndex = GetInRowIndex(index, rowIndex);
    
    v0 = GridPoint(GetVertex0(rowIndex, inRowIndex), resolution, A, B, C);
    v1 = GridPoint(GetVertex1(rowIndex, inRowIndex), resolution, A, B, C);
    v2 = GridPoint(GetVertex2(rowIndex, inRowIndex), resolution, A, B, C);
}

[numthreads(64, 1, 1)]
void SubdivideSector(uint3 threadID : SV_DispatchThreadID)
{
    // Global index provided from dispatch.
    uint globalIndex = threadID.x;
    
    // Determine the sector and the local rod (cell) index.
    uint sectorIndex = globalIndex / rodCountPerSector;
    uint localRodIndex = globalIndex % rodCountPerSector;
    
    float3 v0, v1, v2;
    MapToTriangle(localRodIndex, resolution,
        sectors[sectorIndex].cornerVertex0, sectors[sectorIndex].cornerVertex1, sectors[sectorIndex].cornerVertex2,
        v0, v1, v2);

    // Calculate the center (centroid) of the triangle
    float3 center = (v0 + v1 + v2) / 3.0f;

    // Calculate the surface area of the triangle
    float3 edge1 = v1 - v0;
    float3 edge2 = v2 - v0;
    float surfaceArea = 0.5f * length(cross(edge1, edge2)); // Cross product gives area of parallelogram, divide by 2 for triangle

    // Triangulation info (just store the vertex indices or IDs)
    // Assuming triangulation refers to indices of the vertices (or sector IDs) forming the triangle
    //uint triangulation0 = sectorIndex; // Or some relevant triangulation index
    //uint triangulation1 = sectorIndex + 1; // Example: adjacent sectors
    //uint triangulation2 = sectorIndex + 2; // Example: adjacent sectors
    
    // Store the rod data
    rods[globalIndex].sector = sectorIndex;
    rods[globalIndex].cornerVertex0 = v0;
    rods[globalIndex].cornerVertex1 = v1;
    rods[globalIndex].cornerVertex2 = v2;
    rods[globalIndex].center = center;
    rods[globalIndex].surfaceArea = surfaceArea;
    
    uint rowIndex = GetRowIndex(localRodIndex); // For resolution 3 goes 0 through 3
    uint inRowIndex = GetInRowIndex(localRodIndex, rowIndex);
    
    rods[globalIndex].triangulation0 = 0;
    rods[globalIndex].triangulation1 = 1;
    rods[globalIndex].triangulation2 = 2;
}
